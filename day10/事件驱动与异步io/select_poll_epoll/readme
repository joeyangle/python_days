介绍select\Poll\Epoll异步IO

用户空间与内核空间
对于操作系统而言，为了保证操作系统的安全性，设立内核空间，保证内核空间中数据的
安全，故操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分用户空间

进程切换
为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程
的执行。
从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：
1. 保存处理机上下文，包括程序计数器和其他寄存器。
2. 更新PCB信息。
3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。
4. 选择另一个进程执行，并更新其PCB。
5. 更新内存管理的数据结构。
6. 恢复处理机上下文。
总而言之就是很耗资源
（注：进程控制块（Processing Control Block），是操作系统核心中一种数据结构，主要表示进程状态。
其作用是使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位或与
其它进程并发执行的进程。或者说，OS是根据PCB来对并发执行的进程进行控制和管理的。 PCB通常是
系统内存占用区中的一个连续存区，它存放着操作系统用于描述进程情况及控制进程运行所需的全部信息 ）

进程的阻塞
正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据未到达或
无新工作做等，则由系统自动执行阻塞原语（block），使自己的运行状态变为阻塞状态。可见，进程的阻塞是
进程自身的一种主动行为，也由此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态，是不占用
CPU资源的。

文件描述符fd
文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。


缓存I/O
缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，
操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作
系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。



select、poll、epoll这三者的区别
http://www.cnblogs.com/alex3714/p/4372426.html

windows仅支持select，并且select差不多全平台支持

select与poll没有本质区别，poll没有最大文件描述符数量的限制

poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，
而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。

epoll解决了以上select和poll的问题，通过边缘触发，以上只支持水平触发

Python的select()方法直接调用操作系统的IO接口，它监控sockets,open files, and pipes(所有带fileno()方法的文件句柄)
何时变成readable 和writeable, 或者通信错误，select()使得同时监控多个连接变的简单，并且这比写一个长循环来等待和
监控多客户端连接要高效，因为select直接通过操作系统提供的C的网络接口进行操作，而不是通过Python的解释器。

？？说一点自己的理解，其实就是在接收信息与处理信息之间加了一个队列类似于缓冲区，然后通过select对其先进行一步筛选操作，
以得到各种信息的状态


个人理解
select\Poll\Epoll异步IO
以上是什么？个人认为以上建立了三个缓冲池，将具有相似性质的链接置入同性质的
缓冲池中，并且做相应的处理，依次避免了重复造轮子以及代码逻辑结构的复杂，
就这样来看，通过select\Poll\Epoll对缓冲池的不断监控fd是否发生改变，否则阻塞以减少
CPU占用，这种结构的构建是相当不错的