#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
__title__ = ''
__author__ = 'joeya'
__mtime__ = '2017/5/10'
# code is far away from bugs with the god animal protecting
    I love animals. They taste delicious.
              ┏┓      ┏┓
            ┏┛┻━━━┛┻┓
            ┃      ☃      ┃
            ┃  ┳┛  ┗┳  ┃
            ┃      ┻      ┃
            ┗━┓      ┏━┛
                ┃      ┗━━━┓
                ┃  神兽保佑    ┣┓
                ┃　永无BUG！   ┏┛
                ┗┓┓┏━┳┓┏┛
                  ┃┫┫  ┃┫┫
                  ┗┻┛  ┗┻┛
"""
#协程是一种用户态的轻量级线程
'''
协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈
保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：

协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），
每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。
'''
'''
为什么使用协程呢？好处是什么
    无需线程上下文切换的开销
    无需原子操作锁定及同步的开销
        "原子操作(atomic operation)是不需要synchronized"，所谓原子操作
        是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行
        到结束，中间不会有任何 context switch （切换到另一个线程）。原
        子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序是不可以
        被打乱，或者切割掉只执行部分。视作整体是原子性的核心。
    方便切换控制流，简化编程模型
    高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理
'''
'''
当然也有缺点：
    无法利用多核资源：协程的本质是个单线程，它不能同时将单个cpu的多个核用上
        协程需要和进程配合才能运行在多CPU上，当然我们日常所编写的绝大部分应用
        没有这个必要，除非是CPU密集型应用（多计算）
    进行阻塞操作会阻塞掉整个进程
'''
'''
那么，协程到底是个啥？
协程看上去也是子程序，但执行过程中，在子程序内部可中断，
然后转而执行别的子程序，在适当的时候再返回来接着执行

（？使得逻辑分明的顺序复杂化，使得程序关联更加复杂，当然，应仅限于局部，
逻辑的代价--》性能高效）显著例子：生产者消费者模型
？？个人理解》》》多进程太耗内存资源，同样对于多线程，无需线程上下文切换的开销（参见day9线程调用图），
对于多线程来说，虽然说CPU有时钟频率的存在会在进程间不断地切换，以尽量减少io阻塞带来
的效率降低，但是CPU并不了解一个线程是否执行完成，只是按照规定的频率来切换，这就导致
一个线程往往要走走停停多次才能完成，而且走走停停每次都需要记住暂停位置，这样就占用了
大量的资源
那么将程序运行路径都安排好，自然比程序自己io切换高效，这就是协程

以下四条
必须在只有一个单线程里实现并发
修改共享数据不需加锁
用户程序里自己保存多个控制流的上下文栈
一个协程遇到IO操作自动切换到其它协程
'''

import time
import queue

def consumer(name):
    print("--->starting eating baozi...")
    while True:

        new_baozi = yield
        print("[%s] is eating baozi %s" % (name, new_baozi))
        # time.sleep(1)

def producer():
    r = con.__next__()
    r = con2.__next__()
    n = 0
    while n < 5:
        n += 1
        time.sleep(1)
        con.send(n)
        con2.send(n)
        print("\033[32;1m[producer]\033[0m is making baozi %s" % n)

if __name__ == '__main__':
    con = consumer("c1")
    con2 = consumer("c2")
    p = producer()

'''
以上代码实现了协程的前三条，但是IO时自动切换明显没有实现
协程
所以并不是真正意义上的协程
'''